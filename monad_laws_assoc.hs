--https://wiki.haskell.org/Monad_laws

import Control.Monad

{- for reference

class Monad m where
  (>>=)  :: m a -> (  a -> m b) -> m b
  (>>)   :: m a ->  m b         -> m b
  return ::   a                 -> m a


>>= is left associative innfix operator (inflx)

-}

skip_and_get = do unused <- getLine
                  getLine

get1 = do answer <- skip_and_get
          return answer

-- inline skip_and_get
get2 = do answer <- (do unused <- getLine; getLine) ; return answer

{-
Above is same as:

get1 =  getLine >>= (\line -> return line)
   Above is generated by running lambdabot's @undo command on skip_and_get1.
-}

{- Manually translate to Kleisli form 
Ref:
(>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)

It is right associative (infixr) infix operator.

f >=> g =  \x -> f x >>= g OR

f >=> g =  \x -> (f x >>= g)
-}


-- assoc, f >=> (g >=> h)  ~equivalent to~ (f >=> g) >=> h
get3 = (\x -> getLine) >=> ((\unused -> getLine) >=> (\answer -> return answer))
get4 = ((\x -> getLine) >=> (\unused -> getLine)) >=> (\answer -> return answer)


main = do
  putStrLn "Type something <enter>"
  message <- get1
  putStrLn $ "Your second input : " ++ message
  putStrLn "Again, type something <enter>"
  message <- get2
  putStrLn $ "Your second input : " ++ message
  putStrLn "Once more, type something <enter>"
  message <- get3 "dummy"
  putStrLn $ "Your second input : " ++ message
  putStrLn "Sorry, again, type something <enter>"
  message <- get4 "dummy"
  putStrLn $ "Your second input : " ++ message
