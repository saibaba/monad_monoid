--https://wiki.haskell.org/Monad_laws

import Control.Monad

{- for reference

class Monad m where
  (>>=)  :: m a -> (  a -> m b) -> m b
  (>>)   :: m a ->  m b         -> m b
  return ::   a                 -> m a


>>= is left associative innfix operator (inflx)

-}

get1 = do line <- getLine
          return line

get2 = do getLine

{-
Above is same as:

get1 =  getLine >>= (\line -> return line)
   Above is generated by running lambdabot's @undo command on skip_and_get1.
-}

{- Manually translate to Kleisli form 
Ref:
(>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)

It is right associative (infixr) infix operator.

f >=> g =  \x -> f x >>= g OR

f >=> g =  \x -> (f x >>= g)
-}


-- right identity, f >=> return ~equivalent to~ f
get3 = (\x -> getLine) >=> return
get4 = (\x -> getLine)


main = do
  putStrLn "Type something <enter>"
  message <- get1
  putStrLn $ "Your second input : " ++ message
  putStrLn "Again, type something <enter>"
  message <- get2
  putStrLn $ "Your second input : " ++ message
  putStrLn "Once more, type something <enter>"
  message <- get3 "dummy"
  putStrLn $ "Your second input : " ++ message
  putStrLn "Sorry, again, type something <enter>"
  message <- get4 "dummy"
  putStrLn $ "Your second input : " ++ message
